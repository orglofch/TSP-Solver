/*
* Copyright (c) 2015 Owen Glofcheski
*
* This software is provided 'as-is', without any express or implied
* warranty. In no event will the authors be held liable for any damages
* arising from the use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
*
*    1. The origin of this software must not be misrepresented; you must not
*    claim that you wrote the original software. If you use this software
*    in a product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
*    2. Altered source versions must be plainly marked as such, and must not
*    be misrepresented as being the original software.
*
*    3. This notice may not be removed or altered from any source
*    distribution.
*/

#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <limits>
#include <vector>

#include "tsp.hpp"

using namespace std;

enum CoolingSchedule {
  EXPONENTIAL_COOLING,
  LINEAR_COOLING,
  LOGARITHMIC_COOLING,
};

/*
 * Prints usage
 */
void Usage() {
  cout << "Usage: tsp_sa [city-data] <flags>" << endl;
}

/*
 * Return a random City Tour which starts and ends at start_id
 * given a list of cities without the start_id
 *
 * NOTE: This function will re-order elements of the input list
 */
CityPath RandomTour(const CityDistanceMap &city_distance_map,
                    CityList &city_list, 
                    const CityID &start_id) {  
  CityPath tour(CityList(), 0);
  tour.cities.reserve(city_list.size() + 2);
  tour.cities.push_back(start_id);
  CityID prev = start_id;
  // Random select from city array
  for (unsigned int i = 0; i < city_list.size(); ++i) {
    int rand_index = rand() % (city_list.size() - i);
    tour.cities.push_back(city_list[rand_index + i]);
  
    CityDistanceMap::const_iterator it = 
        city_distance_map.find(make_pair(prev, city_list[rand_index + i]));
    assert(it != city_distance_map.end());
    tour.cost += it->second;

    prev = city_list[rand_index + i];

    Swap(city_list, rand_index + i, i);
  }
  // in case we have only one node
  if (city_list.size() > 0) {
    tour.cities.push_back(start_id);

    CityDistanceMap::const_iterator it =
      city_distance_map.find(make_pair(prev, start_id));
    assert(it != city_distance_map.end());
    tour.cost += it->second;
  }
  return tour;
}

/*
 * Returns a random neighbour for a given City Tour
 * A neighbour is generated by swapping two CityIDs (excluding the ends)
 */
CityPath RandomNeighbour(const CityDistanceMap &city_distance_map, 
                         const CityPath &tour) {
  assert(tour.cities.size() > 3);
  int i = rand() % (tour.cities.size() - 2) + 1; // Exclude start and end
  int j = rand() % (tour.cities.size() - 3) + 1;
  if (j >= i) { // So we don't select same position
    ++j;
  }
  CityPath neighbour(tour.cities, tour.cost);
  Swap(neighbour.cities, i, j);
  neighbour.cost = TotalCost(city_distance_map, neighbour.cities);
  return neighbour;
}

/*
 * Returns a Boltzmann probability given an imput temperature and costs
 */
float BoltzmannProbability(float current_cost, 
                           float new_cost, 
                           float temperature) {
  return exp(-(new_cost - current_cost)/temperature);
}

/*
 * TSP solver, via Simulated Annealing
 *
 * Input:  [city_set] set of all cities
 *         [city_distance_map] mapping of edges to distances
 *         [start_id] city to start at
 *         [start_temperature] the temperature to start at
 *         [entropy] the rate of entropy in the system
 *         [stop_temperature] the temperature to stop at
 *         [print_cost] whether to print the cost of current_path
 *                      each iteration
 *         [print_iterations] whether to print the total number
 *                            of annealing iterations
 * Return: Nothing, prints an approximation to the shortest tour
 *         to stdout.
 */
void Anneal(const CitySet &city_set,
            const CityDistanceMap &city_distance_map, 
            const CityID &start_id,
            float start_temperature,
            float entropy,
            float stop_temperature,
            CoolingSchedule cooling_schedule,
            bool print_cost,
            bool print_iterations) {
  // Create a list of all CityIDs that can be reused to speed
  // up random CityTour generation
  CityList city_list;
  city_list.reserve(city_set.size() - 1); // Excluding "A"
  for (CitySet::const_iterator it = city_set.begin(); 
      it != city_set.end(); ++it) {
    if (*it != start_id) { // Excluding 'A"
      city_list.push_back(*it);
    }
  }
  sort(city_list.begin(), city_list.end());

  // Generate random tour to start at
  CityPath current_tour = 
      RandomTour(city_distance_map, city_list, start_id);
  CityPath all_time_best_tour = current_tour;

  // Immediately return if we have a known solution which won't
  // be improved by annealing
  if (city_set.size() <= 3) {
    cout << current_tour << endl;
    return;
  }

  float temperature = start_temperature;
  
  int iterations = 0;

  while (temperature > stop_temperature) {
    ++iterations;
    if (print_cost) {
      cout << current_tour.cost << endl;
    }

    // Randomly select a move to a neighbour configuration
    CityPath neighbour = RandomNeighbour(city_distance_map, current_tour);
    
    // Set current configuration to neighbour configuration
    // If it's better, or select it according to its
    // Boltzmann Probability
    if (neighbour.cost < current_tour.cost ||
        1.0f * rand() / RAND_MAX < BoltzmannProbability(
            current_tour.cost, neighbour.cost, temperature)) {
      current_tour = neighbour;
      if (current_tour.cost < all_time_best_tour.cost) {
        all_time_best_tour = current_tour;
      }
    }
    // Decrease temperature based on entropy
    switch (cooling_schedule)
    {
      case EXPONENTIAL_COOLING:
        temperature *= entropy;
        break;
      case LINEAR_COOLING:
        temperature -= entropy;
        break;
      case LOGARITHMIC_COOLING:
        temperature = start_temperature / (log(iterations + 1) / log(entropy));
        break;
    }
  }
  if (print_iterations) {
    cout << iterations << endl;
  }
  cout << all_time_best_tour << endl;
}

int main(int argc, char **argv) {
  if (argc < 2) {
    Usage();
    return 1;
  }

  // Default arguments
  string data_file = argv[1];
  CityID start_city_id = "A";
  float start_temperature = 500;
  float entropy = 0.99997442;
  float stop_temperature = 3.0;
  CoolingSchedule cooling_schedule = EXPONENTIAL_COOLING;
  bool print_cost = false;
  bool print_iterations = false;
  time_t seed = time(NULL);

  // Load
  CitySet city_set;
  CityDistanceMap city_distance_map;
  if (!LoadData(data_file, city_set, city_distance_map)) {
    cout << "Failed to load datafile." << endl;
    return 1;
  }

  // Extract flags
  for (int i = 2; i < argc; ++i) {
    if (strcmp(argv[i], "-city") == 0) {
      if (city_set.find(argv[i + 1]) != city_set.end()) {
        start_city_id = argv[i + 1];
        ++i;
      } else {
        cout << "Invalid start city: " << argv[i + 1] << endl;
        return 1;
      }
    } else if (strcmp(argv[i], "-startT") == 0) {
      start_temperature = stof(string(argv[i + 1]));
      ++i;
    } else if (strcmp(argv[i], "-entropy") == 0) {
      entropy = stof(string(argv[i + 1]));
      ++i;
    } else if (strcmp(argv[i], "-stopT") == 0) {
      stop_temperature = stof(string(argv[i + 1]));
      ++i;
    } else if (strcmp(argv[i], "-schedule") == 0) {
      if (strcmp(argv[i + 1], "exponential") == 0) {
        cooling_schedule = EXPONENTIAL_COOLING;
        ++i;
      } else if (strcmp(argv[i + 1], "linear") == 0) {
        cooling_schedule = LINEAR_COOLING;
        ++i;
      } else if (strcmp(argv[i + 1], "logarithmic") == 0) {
        cooling_schedule = LOGARITHMIC_COOLING;
        ++i;
      } else {
        cout << "Invalid cooling schedule: " << argv[i + 1] << endl;
        cout << "Should be one of: [exponential(default), linear, logarithmic]" << endl;
        return 1;
      }
    } else if (strcmp(argv[i], "-pc") == 0) {
      print_cost = true;
    } else if (strcmp(argv[i], "-pi") == 0) {
      print_iterations = true;
    } else if (strcmp(argv[i], "-seed") == 0) {
      seed = stof(string(argv[i + 1]));
      ++i;
    }
  }

  assert(city_set.find(start_city_id) != city_set.end());
  
  // Seed the random number generator
  srand(seed);

  // Anneal
  Anneal(city_set, city_distance_map, start_city_id, start_temperature, 
      entropy, stop_temperature, cooling_schedule, print_cost, print_iterations);

  return 0;
}
